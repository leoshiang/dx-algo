function Dijkstra (圖, 起點) {
	// 儲存每個頂點的最短距離，初始值無限大
	const 距離 = {};
	// 儲存當前頂點的最短路徑的前一個頂點
	const 前驅節點 = {};
	// 儲存未處理的頂點集
	const 未訪問頂點 = new Set();

	// 初始化距離、前驅節點以及未訪問頂點集
	for (const 頂點 of 圖.鄰接表.keys()) {
		距離[頂點] = Infinity; // 初始距離為無窮大
		前驅節點[頂點] = null; // 初始無前驅節點
		未訪問頂點.add(頂點); // 將所有頂點加入未訪問集合
	}

	// 將起點的距離設置為 0
	距離[起點] = 0;

	// 主循環：當還有未訪問頂點時
	while (未訪問頂點.size > 0) {
		// 找到距離值最小的未訪問頂點
		let 最短距離頂點 = null;
		for (const 頂點 of 未訪問頂點) {
			if (最短距離頂點 === null || 距離[頂點] < 距離[最短距離頂點]) {
				最短距離頂點 = 頂點;
			}
		}

		if (距離[最短距離頂點] === Infinity) {
			// 如果所有剩餘頂點的最短距離都是無窮大，那麼我們無法到達這些頂點，跳出循環
			break;
		}

		// 從未訪問頂點集合中移除該頂點
		未訪問頂點.delete(最短距離頂點);

		// 更新相鄰頂點的距離
		const 鄰接清單 = 圖.獲取鄰接清單(最短距離頂點);
		for (const { 終點, 權重 } of 鄰接清單) {
			const 替代距離 = 距離[最短距離頂點] + 權重;
			if (替代距離 < 距離[終點]) {
				// 更新更短的距離
				距離[終點] = 替代距離;
				// 設置前驅節點
				前驅節點[終點] = 最短距離頂點;
			}
		}
	}

	// 返回結果，包括每個頂點的最短距離和前驅節點（可用來重建路徑）
	return { 距離, 前驅節點 };
}

export default Dijkstra;