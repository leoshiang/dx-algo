import 二元堆積 from '../二元堆積.js';

/**
 * Dijkstra 演算法：計算最短路徑（使用二元堆積優化）
 * @param {有向加權圖} 圖 一個有向加權圖實例
 * @param {string|number} 起點 起始頂點
 * @returns {Object} 包含每個頂點的最短距離和路徑的結果
 */
function Dijkstra二元堆積 (圖, 起點) {
	const 距離 = {};
	const 前驅節點 = {};
	const 優先佇列 = new 二元堆積();

	// 初始化距離和前驅節點
	for (const 頂點 of 圖.鄰接表.keys()) {
		距離[頂點] = Infinity; // 初始距離設為無窮大
		前驅節點[頂點] = null; // 初始沒有前驅節點
	}

	// 將起點的距離設置為 0 並加入優先佇列
	距離[起點] = 0;
	優先佇列.插入({ 頂點: 起點, 距離: 0 });

	// 主循環：處理優先佇列中的頂點
	while (!優先佇列.是否為空()) {
		// 移除距離最小的頂點
		const { 頂點: 最短距離頂點, 距離: 當前距離 } = 優先佇列.移除最小值();

		// 遍歷該頂點的所有鄰接邊
		const 鄰接清單 = 圖.獲取鄰接清單(最短距離頂點);
		for (const { 終點, 權重 } of 鄰接清單) {
			const 替代距離 = 當前距離 + 權重;

			// 如果找到更短的距離，更新距離和前驅節點
			if (替代距離 < 距離[終點]) {
				距離[終點] = 替代距離;
				前驅節點[終點] = 最短距離頂點;

				// 將該終點加入優先佇列
				優先佇列.插入({ 頂點: 終點, 距離: 替代距離 });
			}
		}
	}

	// 返回結果：每個頂點的最短距離和前驅節點
	return { 距離, 前驅節點 };
}

export default Dijkstra二元堆積;